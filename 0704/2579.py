n = int(input())

stair_list = [0] * (n+1)  # 0번 인덱스 안쓰고 1~n번 인덱스 사용
max_sum_list = [0] * (n+1)  # i번째 계단까지 올라오는데 점수 최대 기록. 마찬가지로 1~n인덱스 사용

for i in range(n):
    stair_list[i+1] = int(input())

if(n==1): # 이 조건을 안 걸면 2번 인덱스에 접근하려고 해서 index에러가 발생
    print(stair_list[1])
else:
    max_sum_list[1] = stair_list[1]  # 메모리의 주소가 아니라 값을 복사한다. shallow copy 아님
    max_sum_list[2] = stair_list[1] + stair_list[2]
    # n번 계단까지 올라오는 경우는 (1) n-1을 밟고 올라왔을 경우, (2) n-2를 밟고 올라왔을 경우로 나눌 수 있다.
    # (1)의 경우 n-2도 밟았다면, n의 입장에서는 n-1, n-2를 밟은 격이다.
    # 그 조건을 n-1의 입장에서도 생각해보면 n-2, n-3을 밟고 올라온 것이다.
    # 그렇다면 n-3,n-2,n-1,n을 모두 밟아 3계단을 연속으로 밟으면 안된다는 조건에 위배된다.
    # 따라서 (1)에서 n-1을 밟았다면, n-2가 아니라 n-3에서 올라왔어야 한다.
    # 'n-3계단까지의 최댓값'과 'n-1계단', 'n계단'의 합이 (1)의 경우의 가능한 최대다.
    # (2)의 경우 n-2를 밟고 n으로 올라왔다면, 그 전 n-2 계단에서도 n-4계단을 밟고 올라왔을 것이기에 조건에 위배되지 않는다.
    # (1)의 경우에서 나온 값과, (2)에서 나온 값 중 최댓값을 뽑아내면 n번 계단까지의 최대값이 된다.
    # 참고로 n-3번 계단을 밟고 n번 계단을 밟을 일은 없기에 위 두가지 경우만 고려해주면, 재귀적으로 모든 경우를 담을 수 있다.
    # 이 문제는 나중에도 꼭 다시 한번 봐야할 문제
    for i in range(3, n+1):
        max_sum_list[i] = (max((max_sum_list[i-3] + stair_list[i-1] + stair_list[i]), (max_sum_list[i-2] + stair_list[i])))

    print(max_sum_list[n])

